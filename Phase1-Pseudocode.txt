#User will create this object to send using a Client
UserRequest {
    fields:
        objectId
        operation
}


#Client creates this object to send to a head replica
ClientRequest {
    fields:
        objectId
        operation
        clientKey
        requestId

    methods:
        constructor(obj_id, op, key):
            self.objectId = obj_id
            self.operation = op
            self.clientKey = key
}


#Result received from a tail replica
Result {
    requestID
    result
    resultProof
}


#User will create a Client to send/receive multiple UserRequests
Client {
    fields:
        key
        timeoutSpan
        sent            #Set of sent requests
        received        #Set of received responses
        requestCount
    
    methods:
        constructor(tSpan):
            self.key = Olympus.obtainClientKey()
            self.timeoutSpan = tSpan

        #User should use this interface
        sendRequest(UserRequest):
            #Get a unique request id
            requestID = getUniqueReuqestID()

            #Get the current configuration
            config = Olympus.getCurrectConfig()

            #Send a request to the head replica
            dest = config.head
            return __sendRequest(UserRequest, msg = "newRequest", destReplicas = dest)

        __sendRequest(UserRequest, msg, destReplicas):
            config = Olympus.getCurrectConfig()

            #Create a request
            request = new ClientRequest(obj_id = UserRequest.objectId, op = UserRequest.operation, key = self.key)

            #Send the request to the destination replicas
            send <msg, request> to destReplicas
            sent.add(request)

            # request has been sent and wait for at max timeout interval for the result
            timeout(minutes = self.timeoutSpan):
                #Check if we have received
                if request.requestID not in received:
                    #Get the current config. This updates the config incase there are any changes
                    config = Olympus.getCurrectConfig()
                    self.__sendRequest(UserRequest, msg = 'retranmission', destReplicas = config.getAllReplicas())


        #Receive an unvalidated result
        #Note: We assume a user may get mulitple responses for a single request
        receiveReplicaResponse(Result):
            if Result.requestId in sent:
                for each proof in Result.resultProofs
                    replicaPublicKey = config.replicas(proof.replicaID).publicKey
                    if HMAC(Result.result, replicaPublicKey) != proof.signature
                        return error

            return Result.result


        #Received an error. This means the sender replica is immutable
        receiveError(Error):
            config = Olympus.getCurrectConfig()
            __sendRequest(UserRequest, replicas = config.getAllReplicas())
}


Olymupus {
    fields:
        config          #Ordered list of replicas
        replicaCount    #The number of replicas
        wedge_replies   # list of wedge replies obtained from replicas
        signKeys[][]    # 2D array for sing keys for i -> j replica
    
    methods:
        constructor(numberOfReplicas):
            self.replicaCount = numberOfReplicas
            self.config = new Config()
            #Initialize a configuration with empty history
            initHist(self.replicaCount, self.config, hist = {})  #initially the history is empty          
            signKeys = generateSignKeys(replicaCount)
        
        #Creates a new configuration
        initHist(numberOfReplicas, config, hist):
            #Delete old replicas
            config.purgeReplicas()

            #Create each replica
            for id in numberOfReplicas:
                r = new Replica(interReplicaKeys = signKeys[id], signingKey = privateKey, status = Active, history = hist)
                #Add the replica to the config
                config.add(r)

            #Link each replica
            for each replica in config:
                if replica is not the head:
                    replica.previousReplica = replica.index-1
                    replica.headReplica = first replica in config
                if replica is not the tail:
                    replica.nextReplica = replica.index+1
                replica


        #Returns a new identifier and key to the client
        receiveClientKeyRequest():
	        return generateRandomKey()
        

        #Asynchronous method to handle requests from Clients to obtain the replica list
        getCurrectConfig():
            return self.config

        check_valid_wedge_reply(wedge_reply):
            for order_proof in wedge_reply.order_proofs:
                replicaId = order_proof.issuerId
                signKey   = signKeys[replicaId][replicaId+1] 
                if (unsign(signKey.privateKey, order_proof.data) == Success )                
                     order_proof_data = unsign(signKey.privateKey, order_proof.data)
                else:
                    return False                
        
        validateOrderProof(order_proofs):
             for order_proof in order_proofs:
                 if order_proof.operations.distinct.count != 1 # check if only one distinct operation exists in this order proof
                   return False  			       # not correct therefore false
                if order_proof.slots.distinct.count != 1 # check if only one slot is present
                   return False
        
        receiveReconfigureRequest():
            # Request wedge statements from each replica
            wedge_replies = []
            for each replica in config:
		send <"wedge_request"> to replica	
            
            # Wait till obtaining t+1 wedge replies from the replica
            while(wedge_replies < (replicaCount-1)/2+1):
                True
            
            slot_op = {}  # length and operation for each slot
            for wedge_reply in wedge_replies: 
                if (check_valid_reply(wedge_reply.order_proofs) == True)  # check valid source of order_proofs
                   if(validateOrderProof(wedge_reply.order_proofs)):      # check valid content of order_proofs
                      if slot_op[wedge_reply.order_proof.slot] is empty:
                          slot_op[slot] =  [wedge_reply.order_proof.operation, wedge_reply.order_proof.length]
                      else if slot_op[slot] is present:
                         if slot_op[slot].length < wedge_reply.order_proof.length
                            slot_op[slot] = [wedge_reply.order_proof.operation, wedge_reply.order_proof.length]
                         else
                            continue
                   else
                      continue
                else:
                   continue
            
            # Find the maximal orderproofs
            # slot_op contains the maximum length of order proof for each slot and the operation done in each slot
            # create a list of [slot, operation] tuple to recreate replica 
            # Create a new configuration
            
            h = {}                    # creating history to be used for reconfiguring the replicas
            for slot in slot_op:
                h[slot] = slot_op[slot].operation
            
            for i in replicaCount:
                r = new Replica(interReplicaKeys = signKeys[id], signingKey = privateKey, status = Active, history = h)

}
    


Replica {
    fields:
        previousReplica
        nextReplica
        headReplica    # the address to head Replica
        history
        interReplicaKeys
        signingKey
        status
        neighbors
        cache          # cache for storing the results
        headFlag       # boolean flag to check if replica is head or not 
        tailFlag       # boolean flag to check if replica is tail or not
        timeoutSpan    # the timeout for retranmission requests
        responses       # responses obtained from replicas
        pendingRequests # requests whose result shuttle is pending
        allowedOperations = ['query','update' ]
        checkpointNum   # the latest slot number which has been checkpointed  
        currentSlotNum  # the latest slot number completed
        runningState	# contains the values of all objects in the replica


    methods:
        # interReplicaKey is a list of signing key for 2t replicas
        # secretSigningKey will have signing key for each client
        
        constructor(interReplicaKey, secretSigningKey, status, neighbors):
            self.status           = status
            self.interReplicaKey  = interReplicaKey
            self.secretSigningKey = secretSigningKey
            self.neighbors        = neighbours
            if self.headFlag: #If we are the head
                initiateCheckpointTimerThread()


        # Catch all message handler
        handleAsyncRequest(msg, request, client):
	        switch msg:
                'newRequest':
                    handleNewRequest(client, request)
           	    'retransmission':
                    handleRetranmissionRequest(client, request)
	   	        'wedge':
	                handleWedgeRequest(client, request):
           	    'returnShuttle':
                    handleResultShuttle(result, resultProof)
                default:
             	    return Error
        
        # Handler for a result shuttle
        handleResultShuttle(result, resultProof):
            validFlag = True
            for proof in resultProof:
                if valid(proof) != True 
       		        validFlag = False
                    break
            if validFlag == False:         # if the return Shuttle is not valid then ignore
		        return
            else:
                cache[result.id] = result  	  # if it is valid then cache the result
                pendingRequests.delete(result.id) # delete from the list of pending requests
 

        # Asynchronous handler for normal order command requests
        # Multi purpose handler to handle new requests 
        handleNewRequest(client, request):
            # Check if we are active
            if self.state != ACTIVE:
                return Error

            # Generate a new slot if we are the head
            if self.headFlag == True:
                sNum = getNextAvailableSlotNumber()

            # Check validity of client key
		    if valid(client.clientKey) == False:
                return Error     # Client is not registered
                
            orderCommand(slot = sNum, operations = request.operation, objectId = request.objectId)

            
        # Handler for wedge requests    
        handleWedgeRequest(client, request):
            # Make sure our status is Immutable
            self.status = Immutable
            
            # Sign the data and send it to Olympus
            send <"wedge", self.runningState, self.orderProofs, self.checkpointProof> to Olympus


        # Handler for retranmission requests
        handleRetranmissionRequest(client, request):
            if self.status == Immutable:
		        return Error
            else:
                if request.id in cache:
                    return cache[request.id]
                else:
		            if self.headFlag ==  False:     # forward the request to head
                        sendRequestToReplica(headReplica, request)
                        timeout(minutes = self.timeoutSpan):
                        if request.id not in responses   # if no response obtained then reconfig 
                            self.status = Immutable 
    				        Olympus.reconfig()                        
                        else:
                            if request.id in pendingRequests 
			                    timeout(minutes = self.timeoutSpan):
                                    if request.id not in responses  # if no response obtained then reconfig
                                        self.status = Immutable
                                        Olympus.reconfig()
       		                        else:         # similar to new request therefore calling handleRequest
                                        handleNewRequest(client, request)	

       
        # Gets all relevant proofs from the history
        # start from current checkpoint and reach the required slot, using operations in history
        get_proofs_from_history(required_slot):
           proof_statements = self.history[sel.checkpointNum:required_slot]
           return proof_statements
           


            
        # Relates to the orderCommand transition at the replica. Assumes we are active -> This is checked in the new request handler
        orderCommand(slot, operation, objectId):
            # Validate history
            if self.history has slot: # A slot for this command already exists. Cannot issue it twice
                return False

            # Apply running state
            result = runningState[request.objectId].apply(request.operation)

            # Create proofs
            order = new OrderProof(slotNumber = sNum, operation = request.operation, proofs = get_proofs_from_history())
            signedOrder = sign(key = self.signingKey, statement = order)
            orderProof.append(signedOrder)

            signedResult = sign(key = self.signingKey, statement = result)
            resultProof.append(signedResult)

            if not replica.tailFlag:
                send <"order", order, orderProof, resultProof> to self.nextReplica
            else:
                send <"result", requestID, result, resultProof> to request.client      # send result to client
		        send <"ReturnShuttle", result, resultProof> to self.previousReplica    # send the return shuttle
}

OrderProof {
    fields:
        proofs  # list of proofs
        issuer  # the issuer of this proof        
}

Proof {
    fields:
        issuer     # the issuer of the proof which will be the replica id
        operation  # the operation which was performed
        objectId   # object on which operation was performed
        slot       # the unique operation number        
        
}
