import nacl.encoding
import nacl.signing
import pickle
import itertools

STATUS = import_da('status').STATUS
Request = import_da('request').Request
OPTYPE = import_da('request').OPTYPE


class Replica(process):
    def setup(state: dict, history: list, timeout: int, public_keys: list, private_key: object, status: STATUS, head: bool, tail: bool, next_replica: Replica, prev_replica: Replica, head_replica: Replica):
        # Set status
        self.status = STATUS.ACTIVE
        # Create counter for slot numbers... This is only used by the head
        self.slot_counter = itertools.count()

    def run():
        await(False)

    # Relates to order command transition at replica
    def order_command(req):
        # Cast input to strings
        key = str(req.key)
        val = str(req.value)

        success = False
        results = 'fail'
        if req.op == OPTYPE.PUT:
            state[key] = val
            results = 'OK'
            success = True
        elif req.op == OPTYPE.GET:
            success = True
            if state.get(key):
                results = state.get(key)
            else:
                results = ''
        elif req.op == OPTYPE.SLICE:
            s = state.get(key)
            # Check if the value exists
            if s:
                i, j = req.value  # Todo: Prevent this from throwing when not a valid tuple
                # Check i and j indices
                if 0 <= i and i < j and j < len(s):
                    state[key] = state[key][i:j]
                    success = True
                    results = 'OK'
        elif req.op == OPTYPE.APPEND:
            if state.get(key):
                state[key] = state[key] + val
                success = True
                results = 'OK'

        return success, results

    # Performs outgoing actions
    def forward_results(req, order_proof, order_stmt):
        # Sign the order statement
        signed_stmt = self.private_key.sign(pickle.dumps(order_stmt))
        # Add order statement to order proof
        order_proof.append(signed_stmt)


        # For logging
        results = order_stmt[1][1]
        # Forward results
        if self.tail:
            payload = (results, order_proof, req.request_id)
            send(("Response", payload), to=req.client)
            output("Sent Response,", results, " to Client:", req.client, "for Request ID:", req.request_id)
            output("\n\n State:", self.state)
            # Todo: Return shuttles
        else:
            # Send to the next replica
            payload = (req.get_body(), order_proof)
            send(("Order", payload), to=self.next_replica)
            output("Sent Response,", results, ", for Client:", req.client, "Request ID:", req.request_id, " to Replica:", self.next_replica)

    # Core logic for receiving a new request
    #   req is a Request object
    def process_new_request(req):
        # Todo: Do validation

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", req.request_id)), to=req.client)

        # Check if we are the head, exit if we aren't
        if not self.head:
            return send(("Error", ("Not Head", req.request_id)), to=req.client)

        # Todo: Do more validation? Check for valid signing keys, etc...

        # Generate a slot number
        slot_num = next(self.slot_counter)
        # Generate the order statement
        order = order_command(req)
        order_stmt = (slot_num, order)

        return forward_results(req, [], order_stmt)

    # Handler for new requests
    def receive(msg=("Request", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received New Request ID:", request.request_id)

        return process_new_request(request)

    # Validates order proof signatures and contents
    def validate_order_proofs(order_proofs, slot_num, order):
        # Check for valid order proof signatures
        for i, proof in enumerate(order_proofs):
            try:
                self.public_keys[i].verify(proof)
            except:
                # Todo: What to do on a verification error
                output("----Order Proof Signature Validation Error---")
                return False

        # Check for valid order proof contents
        for proof in order_proofs:
            temp_slot, temp_order = pickle.loads(proof.message)
            if slot_num != temp_slot or order != temp_order:
                output("----Order Proof Content Validation Error---")
                return False

        # No errors
        return True

    # Handle order commands from replicas. An order message is sent to the next replica in the list
    def receive(msg=("Order", m), from_=replica):
        # Parse message
        body, order_proofs = m
        request = Request.from_body(body)
        output("Received Order Command for Client:", request.client, "Request ID:", request.request_id)

        # Make sure we got a message from the correct replica
        if replica != self.prev_replica:
            # Todo: Should we report misbehavior? (ie. the head shouldn't receive order commands)
            output("Received an order command but not from the previous replica in the chain")
            return
        # Make sure our status is active
        elif self.status != STATUS.ACTIVE:
            # Do nothing
            # Todo: Is this right?
            return
        else:
            # Do validation
            slot_num, temp_order = pickle.loads(order_proofs[0].message)
            output("Validating order proofs for Client:", request.client, "Request ID:", request.request_id)
            order_proofs_valid = validate_order_proofs(order_proofs, slot_num, temp_order)
            if order_proofs_valid:
                output("Order Proof Signatures and Contents Validated for Client:", request.client, "Request ID:",
                       request.request_id)
            else:
                # Todo: Should we send proof of misbehavior?
                return

            # Generate the order statement
            # Todo: Make sure there are no holes in order commands
            order = order_command(request)
            order_stmt = (slot_num, order)

            return forward_results(request, order_proofs, order_stmt)

    # Handler for client retransmission
    def receive(msg=("Retransmission", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received Retransmit for Client:", request.client, "Request ID", request.request_id)

        found_in_cache = False

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", request.request_id)), to=client)
        # Todo: Check the cache for a response
        elif found_in_cache:
            output("Found in cache")
        else:
            # Check if we are the head replica
            if self.head:
                # Todo: Check if there is a pending request (ie. There is a request in the sent list with the request_id)
                pending_request = False
                if pending_request:
                    # Wait for a shuttle response with a timeout
                    shuttle_response = False
                    if await(shuttle_response):
                        # Check status, which can change while we await
                        if self.status == STATUS.ACTIVE:
                            # Todo: Get the response from the shuttle
                            response = "Gotten"
                            # Send the response to the client and exit
                            return send("Response", (response, request.request_id), to=client)
                    # No response obtained
                    elif timeout(timeout):
                        # Become immutable and reconfigure
                        self.status == STATUS.IMMUTABLE
                        # Todo: Send reconfiguration request to Olympus
                        return
                else:
                    # Treat this retransmission as a new request
                    output("Treating Retransmission as a New Request")

                    return process_new_request(request)
            # If we are not the head replica
            else:
                # Forward the request to the head replica and set a timer
                head_replica = self.head_replica
                send(("Retransmission", body), to=head_replica)

                # Wait for a shuttle response with a timeout
                shuttle_response = False
                if await(shuttle_response):
                    # Todo: Get the response from the shuttle
                    response = "Gotten"
                    # Send the response to the client and exit
                    return send("Response", (response, request.request_id), to=client)
                # No response obtained
                elif timeout(timeout):
                    # Become immutable and reconfigure
                    self.status == STATUS.IMMUTABLE
                    # Todo: Send reconfiguration request to Olympus
                    return