import nacl.encoding
import nacl.signing
import nacl.hash
from nacl.bindings.utils import sodium_memcmp
import pickle
import itertools
import logging

STATUS  = import_da('status').STATUS
Request = import_da('request').Request
OPTYPE  = import_da('request').OPTYPE
logger  = logging.getLogger('main_logger')


class Replica(process):
    def setup(state: dict, 
        history: list, 
        timeout: int, 
        public_keys: list, 
        private_key: object, 
        status: STATUS, 
        head: bool, 
        tail: bool, 
        next_replica: Replica,
        prev_replica: Replica, 
        head_replica: Replica,
        failures: list,
        index: int,
        olympus: Olympus,
        configuration: int,
        checkpoint_interval: int):
        
        # Set status
        self.status = STATUS.ACTIVE
        # Create counter for slot numbers... This is only used by the head
        self.slot_counter = itertools.count()
        # Assume slot numbers start at 0
        self.last_slot_number = -1
        # Create the processing list
        self.processing_list = []
        # Create the cache
        self.cache = {}
        # hash for storing number of requests received from a client
        self.client_requests = {}
        # hash for storing number of requests receieved from a client which are coming from previous replica
        self.shuttle_requests = {}
        # hash for storing number of result shuttle
        self.result_shuttle_requests = {}
        # checkpoint interval
        self.checkpoint_interval = checkpoint_interval

        logger.debug("Got checkpoint_interval: " + str(checkpoint_interval))
        # All the trigger flags
        self.crash = False
        self.drop_result_stmt = False
        self.change_operation = False
        self.change_result    = False
        self.failure_string   =  ""
        self.configuration    = configuration
        self.order_history    = {}
        self.processed_checkpoint = 0                   # number of checkpoint shuttle processed
        self.processed_checkpoint_completed = 0         # number of completed checkpoint shuttle processed

    def crash_condition():
        return self.crash
    
    def update_trigger_flags_new():
        print('Filler method')

    def update_trigger_flags(request, flag):
        if flag == 0:
            if request.client_id in self.client_requests:
                self.client_requests[request.client_id] = self.client_requests[request.client_id] + 1
            else:
                self.client_requests[request.client_id] = 1
        elif flag == 1:
            if request.client_id in self.shuttle_requests:
                self.shuttle_requests[request.client_id] = self.shuttle_requests[request.client_id] + 1
            else:
                self.shuttle_requests[request.client_id] = 1
        elif flag == 2:
            if request.client_id in self.result_shuttle_requests:
                self.result_shuttle_requests[request.client_id] = self.result_shuttle_requests[request.client_id] + 1
            else:
                self.result_shuttle_requests[request.client_id] = 1

        checkhash = {}
        checkhash[0] = 'client_request'
        checkhash[1] = 'shuttle'
        checkhash[2] = 'result_shuttle'

        if flag  == 0:
            temphash = self.client_requests
        elif flag == 1:
            temphash = self.shuttle_requests
        elif flag == 2:
            temphash = self.result_shuttle_requests

        for f in failures:
            #logger.debug('FAILURES ARE ' + str(f))
            #logger.debug('FAILURE REQUESTS ARE ' + str(request.client_id) + str(temphash[request.client_id]))
            if f[2][0] == request.client_id and f[2][1] == temphash[request.client_id] and f[1] == checkhash[flag]:
                if f[0] == OPTYPE.CRASH:    # crash the replica
                    self.crash = True
                    self.failure_string = checkhash[flag]+'('+str(f[2][0])+','+str(temphash[request.client_id])+')'+',crash()'
                    logger.error('crash TRIGGER FLAG CRASH UPDATED TO TRUE '+str(flag)+' '+self.failure_string)
                elif f[0] == OPTYPE.DROPRESULTSTMT: # drop result shuttle
                    self.drop_result_stmt = True
                    self.failure_string = checkhash[flag]+'('+str(f[2][0])+','+str(temphash[request.client_id])+')'+',drop_result_stmt()'
                    logger.error('drop_result_stmt TRIGGER DROP SHUTTLE UPDATED TO TRUE '+str(flag)+' '+self.failure_string)
                elif f[0] ==  OPTYPE.CHANGEOPERATION: # change operation
                    self.change_operation = True
                    self.failure_string = checkhash[flag]+'('+str(f[2][0])+','+str(temphash[request.client_id])+')'+',change_operation()'
                    logger.error('change_operation TRIGGER CHANGE OPERATION UPDATED TO TRUE '+str(flag)+' '+self.failure_string)
                elif f[0] == OPTYPE.CHANGERESULT:   # change result
                    self.change_result = True
                    self.failure_string = checkhash[flag]+'('+str(f[2][0])+','+str(temphash[request.client_id])+')'+',change_result()'
                    logger.error('change_result TRIGGER CHANGE RESULT UPDATED TO TRUE '+str(flag)+' '+self.failure_string)
        return

    def run():
        await(crash_condition())

    # Relates to order command transition at replica. Issues an order command and returns a hashed result
    def order_command(req):
        # Cast input to strings
        key = str(req.key)
        val = str(req.value)

        if change_operation:
            req.op = OPTYPE.GET
            change_operation =  False
            logger.error('CHANGING OPERATION FAILURE ' + str(key) +'  '+str(val))

        success = False
        results = 'fail'
        if req.op == OPTYPE.PUT:
            state[key] = val
            results = 'OK'
            success = True
        elif req.op == OPTYPE.GET:
            success = True
            if state.get(key):
                results = state.get(key)
            else:
                results = ''
        elif req.op == OPTYPE.SLICE:
            s = state.get(key)
            # Check if the value exists
            if s:
                i, j = req.value  # Todo: Prevent this from throwing when not a valid tuple
                # Check i and j indices
                if 0 <= i and i < j and j < len(s):
                    state[key] = state[key][i:j]
                    success = True
                    results = 'OK'
        elif req.op == OPTYPE.APPEND:
            if state.get(key):
                state[key] = state[key] + val
                success = True
                results = 'OK'

        if change_result:
            results = 'OK'
            change_result =  False
            logger.error('INSERTING CHANGE RESULT FAILURE ' + str(results)+ '  ' +str(success))

        return success, results

    # Performs outgoing actions
    def forward_results(req, order_proofs, result_proofs, order_stmt, result_stmt, result, checkpoint_flag):
        # Sign the order statement and add it to the order proof
        signed_order_stmt = self.private_key.sign(pickle.dumps(order_stmt))
        order_proofs.append(signed_order_stmt)
        # Sign the result statement and add it to the result proof
        signed_result_stmt = self.private_key.sign(pickle.dumps(result_stmt))
        result_proofs.append(signed_result_stmt)

        # Forward results
        if self.tail:
            payload = (result, result_proofs, req.request_id)
            send(("Response", payload), to=req.client)
            logger.debug("Sent Response," + str(result) + " to Client:"  + str(req.client_id) +" for Request ID:" +
                         str(req.request_id))
            logger.debug("State:" + str(self.state))

            # Do validation...
            # Todo: Deduplicate this code
            if validate_result_proof(result_proofs):
                # If valid, add to cache
                self.cache[req.get_body()] = (result, result_proofs)
                # Send return shuttles if we are not the head
                if not self.head:
                    # Forward the result shuttle to the previous replica
                    return_payload = (req.get_body(), result, result_proofs)
                    send(("ResultShuttle", return_payload), to=self.prev_replica)
                    logger.debug("Sent Return Shuttle for Client: " + str(req.client_id) + " Request ID: " +
                                 str(req.request_id) + " to Replica:" + str(self.prev_replica))
            else:
                # Become immutable and reconfigure
                self.status = STATUS.IMMUTABLE
                logger.error("Validation of return shuttle failed. Becomming immutable and sending a reconfig request to Olympus")
                body = ('ResultShuttle', index, request.request_id, self.configuration)
                send(("ReConfig", body), to=self.olympus)
                return None
        else:
            # Send to the next replica
            if drop_result_stmt:
                order_proofs     = order_proofs[1:]
                result_proofs    = result_proofs[1:]
                drop_result_stmt = False
                logger.error('----FAILURE INJECTION DROPPING THE RESULT PROOF OF HEAD -------')
            
            payload = (req.get_body(), order_proofs, result_proofs)
            send(("Order", payload), to=self.next_replica)
            logger.debug("Sent Response," + str(result) + ", for Client:" + str(req.client_id) + "Request ID:"
                         + str(req.request_id) + " to Replica:" + str(self.next_replica))

    # Core logic for receiving a new request
    #   req is a Request object
    def process_new_request(req):
        # Todo: Do validation

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", req.request_id)), to=req.client)

        # Check if we are the head, exit if we aren't
        if not self.head:
            return send(("Error", ("Did not send to the head replica", req.request_id)), to=req.client)

        # Todo: Do more validation? Check for valid signing keys from client, etc...

        # Generate a slot number. By definition, the head does not have holes
        slot_num = next(self.slot_counter)
        logger.debug("Slot Number:" + str(slot_num))
        # Generate the order statement
        order = req  # Retain the semantics of the paper
        result = order_command(order)
        hashed_result = nacl.hash.sha256(pickle.dumps(result))
        order_stmt = (slot_num, order)
        result_stmt = (order, hashed_result)
        order_proofs = []
        result_proofs = []
        checkpoint_flag = "False"
        return forward_results(req, order_proofs, result_proofs, order_stmt, result_stmt, result, checkpoint_flag)

    # Handler for new requests
    def receive(msg=("Request", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        logger.debug("Received New Request ID: " + str(request.request_id)+" --->>>  "+str(request.op)+', '+str(request.key)+', '+str(request.value))

        update_trigger_flags(request, 0)  #client_requests triggers        
        return process_new_request(request)

    # Validates order proof signatures and contents
    def validate_order_proofs(order_proofs):
        # Check length of order_proofs
        if len(order_proofs) != self.index:
            logger.error("----Order Proof Error: Truncated Proofs----")
            return False

        first_proof = order_proofs[0]
        # Check for valid order proof signatures
        for i, proof in enumerate(order_proofs):
            try:
                self.public_keys[i].verify(proof)
            except:
                logger.error("----Order Proof Signature Validation Error---")
                return False

        # Check for valid order proof contents
        for proof in order_proofs:
            if proof.message != first_proof.message:
                logger.error("----Order Proof Content Validation Error--- ")
                return False

        # No errors
        return True

    # Duplicate code in client.da
    def validate_result_proof(result_proof):
        # Check for truncation
        if len(result_proof) != len(self.public_keys):
            return False

        # Check for valid proof signatures
        for i, proof in enumerate(result_proof):
            try:
                self.public_keys[i].verify(proof)
            except:
                logger.error("----Result Proof Signature Validation Error---")
                return False

        # Hash the result
        first_result_stmt = pickle.loads(result_proof[0].message)
        orig_order, response_hash = first_result_stmt
        for proof in result_proof:
            order, result_hash = pickle.loads(proof.message)
            # Compare order command contents
            if not orig_order.get_body() == order.get_body():
                logger.error("---Result Proof Order Validation Error---")
                return False
            # Compare result hash
            if not sodium_memcmp(response_hash, result_hash):
                logger.error("---Result Proof Hash Validation Error---")
                return False

        return True

    # Process pending orders if there are no holes in slot number
    def process_ready_orders(order_proofs, result_proofs):
        # Check for holes
        self.processing_list.sort()
        for pending in self.processing_list:
            current_slot, request = pending
            if (self.last_slot_number + 1) == current_slot:
                logger.debug("No holes. Committing Slot: " + str(current_slot))
                # Generate the order statement
                # Note: This is duplicate code from process_new_request
                order = request  # Retain the semantics of the paper
                result = order_command(order)
                hashed_result = nacl.hash.sha256(pickle.dumps(result))
                order_stmt = (current_slot, order)
                result_stmt = (order, hashed_result)

                # Update the last slot number
                self.last_slot_number = current_slot
                order_history[current_slot] = [order_proofs, result_proofs]
                # Remove from processing list
                checkpoint_flag = "False"
                self.processing_list.remove(pending)
                if not forward_results(request, order_proofs, result_proofs, order_stmt, result_stmt, result, checkpoint_flag):
                    return False

    # Handle order commands from replicas. An order message is sent to the next replica in the list
    def receive(msg=("Order", m), from_=replica):
        # Parse message
        body, order_proofs, result_proofs = m
        request = Request.from_body(body)
        logger.debug("Received Order Command for Client: " + str(request.client_id) + " Request ID:" +
                     str(request.request_id))

        update_trigger_flags(request, 1)    #shuttle triggers

        # Make sure we got a message from the correct replica
        if replica != self.prev_replica:
            # Todo: Should we report misbehavior?
            logger.error("Received an order command from invalid sender")
            return
        # Make sure our status is active
        elif self.status != STATUS.ACTIVE:
            # Do nothing
            logger.debug("Received an order command while not active... Not going to do anything.")
            # Todo: Should we send a reconfig to Olympus?
            return
        else:
            # Do validation
            logger.debug("Validating order proofs for Client: " + str(request.client_id) + " Request ID:"
                         + str(request.request_id))
            order_proofs_valid = validate_order_proofs(order_proofs)
            if order_proofs_valid:
                logger.debug("Order Proof Signatures and Contents Validated for Client: " + str(request.client_id) +
                             " Request ID: " + str(request.request_id))
            else:
                # Validation error... become immutable and reconfigure
                logger.error('Order proof validaiton error. Issuing a reconfig from Olympus')
                self.status = STATUS.IMMUTABLE
                body = ('OrderProof', index, request.request_id, self.configuration)
                send(("ReConfig", body), to=self.olympus)
                return

            slot = pickle.loads(order_proofs[0].message)[0]

            # Add the order to the pending orders list
            pending_order = (slot, request)
            self.processing_list.append(pending_order)
            # Attempt to commit ready orders
            return process_ready_orders(order_proofs, result_proofs)

    # Handle checkpoint shuttle commands from replicas. A checkpoint shuttle is sent to the next replica in the list
    def receive(msg=("Checkpoint", m), from_=replica):
        # Parse message
        checkpoint_hash, checkpoint_num, prev_replica_id = m
        logger.debug("Received Checkpoint Shuttle from Replica: " + str(prev_replica_id) + " Checkpoint Num: " + str(checkpoint_num))

        # increment the counter for processed checkpoint
        
        # Do validation
        logger.debug("Validating Checkpoint hash " + str(checkpoint_hash))

        order_proofs_valid = validate_order_proofs(order_proofs)
        if order_proofs_valid:
            logger.debug("Order Proof Signatures and Contents Validated for Client: " + str(request.client_id) +
                         " Request ID: " + str(request.request_id))
        else:
            logger.error('Checkpoint Proof failed at replica '+str(index))
            self.status = STATUS.IMMUTABLE
            body = ('Checkpoint', index, checkpoint_num, self.configuration)
            send(("ReConfig", body), to=olympus)
            return

        slot = pickle.loads(order_proofs[0].message)[0]

        # Add the order to the pending orders list
        pending_order = (slot, request)
        self.processing_list.append(pending_order)
        # Attempt to commit ready orders
        return process_ready_orders(order_proofs, result_proofs)


    # Handler for client retransmission
    def receive(msg=("Retransmission", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        logger.debug("Received Retransmit for Client: " + str(request.client_id) + " Request ID" + str(request.request_id))

        update_trigger_flags(request, 0) #

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            logger.error("We are not active for this retransmission")
            # Send an Error response and exit
            return send(("Error", ("Not Active", request.request_id)), to=client)
        # Check the cache for a response
        elif self.cache.get(body):
            logger.debug("Found in cache")
            cached_result, cached_result_proof = self.cache.get(body)
            # Return the cached result
            payload = (cached_result, cached_result_proof, request.request_id)
            logger.debug("Send cached result for Client: " + str(request.client_id) + " Request ID: "
                         + str(request.request_id))
            return send(("Response", payload), to=client)
        else:
            # Check if we are the head replica
            if self.head:
                # Check if there is a pending request (ie. There is a request in the sent list with the request_id)
                pending_request = some(sent(("Order", (b, _, _))), has= b==body)
                if pending_request:
                    logger.debug("Pending request for Client: " + str(request.client_id) + " Request ID: " + str(request.request_id))
                    # Wait for a result shuttle response with a timeout
                    # Todo: Await for a proof that is valid... validate
                    if await(some(received(("ResultShuttle", (b, r, r_proofs))), has= b==body)):
                        # Check status, which can change while we await
                        if self.status == STATUS.ACTIVE:
                            # Get the response from the shuttle and send the response to the client and exit
                            payload = (r, r_proofs, request.request_id)
                            return send("Response", payload, to=client)
                    # No response obtained
                    elif timeout(timeout):
                        # Become immutable and reconfigure
                        logger.error("HEAD replica became IMMUTABLE due to timeout since result proof shuttle not received for Request ID: " +
                            str(request.request_id))
                        self.status = STATUS.IMMUTABLE
                        body = ('ResultShuttle', index, request.request_id, self.configuration)
                        send(("ReConfig", body), to=self.olympus)
                        return
                else:
                    # Treat this retransmission as a new request
                    logger.debug("Treating Retransmission as a New Request")

                    return process_new_request(request)
            # If we are not the head replica
            else:
                # Forward the request to the head replica and set a timer
                head_replica = self.head_replica
                send(("Retransmission", body), to=head_replica)

                # Wait for a result shuttle response with a timeout
                # Todo: Await for a proof that is valid... validate
                if await(some(received(("ResultShuttle", (b, r, r_proofs,))), has=b == body)):
                    # Check status, which can change while we await
                    if self.status == STATUS.ACTIVE:
                        # Get the response from the shuttle and send the response to the client and exit
                        payload = (r, r_proofs, request.request_id)
                        return send("Response", payload, to=client)
                # No response obtained
                elif timeout(timeout):
                    # Become immutable and reconfigure
                    self.status = STATUS.IMMUTABLE
                    logger.error("NON HEAD replica became IMMUTABLE due to timeout since result proof shuttle not received for Request ID: " +
                            str(request.request_id))
                    body = ('ResultShuttle', index, request.request_id, self.configuration)
                    send(("ReConfig", body), to=self.olympus)
                    return

    # Handler for the result shuttle
    def receive(msg=("ResultShuttle", m), from_=sender):
        # Parse Message
        body, result, result_proofs, = m
        request = Request.from_body(body)
        logger.debug("Received Result Shuttle for Client: " + str(request.client_id) + " Request ID: " +
                     str(request.request_id) + " from: " + str(sender))

        update_trigger_flags(request, 2)
        # Todo: Validate sender identity? Should we care or is validating the result proof enough?

        # Validate result proof
        if validate_result_proof(result_proofs):
            logger.debug("Validated Result Shuttle for Client " + str(request.client_id) + " Request ID: " +
                         str(request.request_id) + " from:" + str(sender))
            # Add valid result to cache
            self.cache[body] = (result, result_proofs)
            # Send return shuttles if we are not the head
            if not self.head:
                # Forward the result shuttle to the previous replica
                return_payload = (request.get_body(), result, result_proofs)
                send(("ResultShuttle", return_payload), to=self.prev_replica)
                logger.debug("Sent Return Shuttle for Client: " + str(request.client_id) + " Request ID:"
                             + str(request.request_id) + " to Replica: " + str(self.prev_replica))
        else:
            # Become immutable and ask olympus for a reconfigure
            logger.error("Validation of return shuttle failed for Client: " + str(request.client_id) + " Request ID: "
                         + str(request.request_id) + " from: " + str(sender))
            logger.info("Becomming immutable and asking for a reconfig")
            self.status = STATUS.IMMUTABLE
            body = ('ResultShuttle', index, request.request_id, self.configuration)
            send(("ReConfig", body), to=self.olympus)
            return

    # Handler for a wedge request from Olympus
    def receive(msg=("wedgeRequest", m), from_=sender):
        logger.debug("Received a wedge request from: " + str(sender))
        # Ignore if the sender is not olympus
        if sender != self.olympus:
            logger.debug("Ignoring wedge request because the sender is not olympus")
            return

        # Set status to immutable
        self.status = STATUS.IMMUTABLE

        # Todo: Send replica state
        wedge_payload = (self.configuration)
        return send(("wedgeResponse", wedge_payload), to=self.olympus)
