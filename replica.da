STATUS = import_da('status').STATUS
Request = import_da('request').Request
OPTYPE = import_da('request').OPTYPE


class Replica(process):
    def setup(state: dict, history: list, timeout: int, public_keys: list, private_key: object, status: STATUS, head: bool, tail: bool, next_replica: Replica, prev_replica: Replica, head_replica: Replica):
        # Set status
        self.status = STATUS.ACTIVE

    def run():
        await(False)

    # Relates to order command transition at replica
    def order_command(req):
        # Enforce str to str input
        response = False
        if req.op == OPTYPE.PUT:
            state[req.key] = req.value
            response = True
        elif req.op == OPTYPE.GET:
            if state.get(req.key):
                response = state.get(req.key)
            else:
                response = ""
        elif req.op == OPTYPE.SLICE:
            response = False
            s = state.get(req.key)
            # Check if the value exists
            if s:
                i, j = req.value
                # Check i and j indices
                if 0 < i and i < j and j < len(s):
                    state[req.key] = state[req.key][i:j]
                    response = True
        elif req.op == OPTYPE.APPEND:
            response = False
            if state.get(req.key):
                state[req.key] = state[req.key] + req.value
                response = True

        # Todo: Change this section. This was done for testing... This sections handles responding
        if response:
            if self.tail:
                send(("Response", (response, req.request_id)), to=req.client)
                output("Sent Response,", response, ", for Request ID:", req.request_id, " to Client:", req.client)
                # Todo: Return shuttles
            else:
                # Todo: Append order proofs...

                # Send to the next replica
                send(("Order", req.get_body()), to=self.next_replica)
                output("Sent Response,", response, ", for Request ID:", req.request_id, " to Replica:", self.next_replica)
        else:
            # Todo: Should this be the logic?
            output("Invalid Result. Dropping Request:", req.request_id)

    # Core logic for receiving a new request
    #   req is a Request object
    def process_new_request(req):
        # Todo: Do validation

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", req.request_id)), to=req.client)

        # Check if we are the head, exit if we aren't
        if not self.head:
            return send(("Error", ("Not Head", req.request_id)), to=req.client)

        # Todo: Do more validation? Check for valid signing keys, etc...

        # Todo: Check for success/failure of order command
        return order_command(req)

    # Handler for new requests
    def receive(msg=("Request", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received New Request ID:", request.request_id)

        return process_new_request(request)

    # Handle order commands from replicas. An order message is sent to the next replica in the list
    def receive(msg=("Order", body), from_=replica):
        # Parse message
        request = Request.from_body(body)
        output("Received Order Command ID:", request.request_id)

        # If we are the head, do not process
        if replica != self.prev_replica:
            # Todo: Should we report misbehavior? (ie. the head shouldn't receive order commands)
            output("Received an order command but not from the previous replica in the chain")
            return
        else:
            # Make sure our status is Active
            if self.status != STATUS.ACTIVE:
                # Do nothing
                return

            # Todo: Check for valid signing keys, etc...

            # Todo: Check for success/failure of order command
            return order_command(request)

    # Handler for client retransmission
    def receive(msg=("Retransmission", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received Retransmit Request ID", request.request_id)

        found_in_cache = False

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", request.request_id)), to= client)
        # Todo: Check the cache for a response
        elif found_in_cache:
            output("Found in cache")
        else:
            # Check if we are the head replica
            if self.head:
                # Todo: Check if there is a pending request (ie. There is a request in the sent list with the request_id)
                pending_request = False
                if pending_request:
                    # Wait for a shuttle response with a timeout
                    shuttle_response = False
                    if await(shuttle_response):
                        # Check status, which can change while we await
                        if self.status == STATUS.ACTIVE:
                            # Todo: Get the response from the shuttle
                            response = "Gotten"
                            # Send the response to the client and exit
                            return send("Response", (response, request.request_id), to= client)
                    # No response obtained
                    elif timeout(timeout):
                        # Become immutable and reconfigure
                        self.status == STATUS.IMMUTABLE
                        # Todo: Send reconfiguration request to Olympus
                        return
                else:
                    # Treat this retransmission as a new request
                    output("Treating Retransmission as a New Request")

                    return process_new_request(request)
            # If we are not the head replica
            else:
                # Forward the request to the head replica and set a timer
                head_replica = self.head_replica
                send(("Retransmission", body), to=head_replica)

                # Wait for a shuttle response with a timeout
                shuttle_response = False
                if await(shuttle_response):
                    # Todo: Get the response from the shuttle
                    response = "Gotten"
                    # Send the response to the client and exit
                    return send("Response", (response, request.request_id), to=client)
                # No response obtained
                elif timeout(timeout):
                    # Become immutable and reconfigure
                    self.status == STATUS.IMMUTABLE
                    # Todo: Send reconfiguration request to Olympus
                    return