import itertools

STATUS = import_da('status').STATUS
Request = import_da('request').Request
OPTYPE = import_da('request').OPTYPE


class Replica(process):
    def setup(state: dict, history: list, timeout: int, public_keys: list, private_key: object, status: STATUS, head: bool, tail: bool, next_replica: Replica, prev_replica: Replica, head_replica: Replica):
        # Set status
        self.status = STATUS.ACTIVE
        # Create counter for slot numbers... This is only used by the head
        self.slot_counter = itertools.count()

    def run():
        await(False)

    # Relates to order command transition at replica
    def order_command(req):
        # Cast input to strings
        key = str(req.key)
        val = str(req.value)

        success = False
        results = 'fail'
        if req.op == OPTYPE.PUT:
            state[key] = val
            results = 'OK'
            success = True
        elif req.op == OPTYPE.GET:
            success = True
            if state.get(key):
                results = state.get(key)
            else:
                results = ''
        elif req.op == OPTYPE.SLICE:
            s = state.get(key)
            # Check if the value exists
            if s:
                i, j = req.value  # Todo: Prevent this from throwing when not a valid tuple
                # Check i and j indices
                if 0 < i and i < j and j < len(s):
                    state[key] = state[key][i:j]
                    success = True
                    results = 'OK'
        elif req.op == OPTYPE.APPEND:
            if state.get(key):
                state[key] = state[key] + val
                success = True
                results = 'OK'

        return success, results

    # Performs outgoing actions
    def forward_results(req, order_proof, order_stmt):
        # Add order statement to order proof
        order_proof.append(order_stmt)
        results = order_stmt[1][1]

        # Todo: Sign the order statement or proof?

        # Forward results
        if self.tail:
            payload = (results, order_proof, req.request_id)
            send(("Response", payload), to=req.client)
            output("Sent Response,", results, ", for Request ID:", req.request_id, " to Client:", req.client)
            # Todo: Return shuttles
        else:
            # Send to the next replica
            payload = (req.get_body(), order_proof)
            send(("Order", payload), to=self.next_replica)
            output("Sent Response,", results, ", for Request ID:", req.request_id, " to Replica:", self.next_replica)

    # Core logic for receiving a new request
    #   req is a Request object
    def process_new_request(req):
        # Todo: Do validation

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", req.request_id)), to=req.client)

        # Check if we are the head, exit if we aren't
        if not self.head:
            return send(("Error", ("Not Head", req.request_id)), to=req.client)

        # Todo: Do more validation? Check for valid signing keys, etc...

        # Generate a slot number
        slot_num = next(self.slot_counter)
        # Generate the order statement
        order = order_command(req)
        order_stmt = (slot_num, order)

        return forward_results(req, [], order_stmt)

    # Handler for new requests
    def receive(msg=("Request", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received New Request ID:", request.request_id)

        return process_new_request(request)

    # Handle order commands from replicas. An order message is sent to the next replica in the list
    def receive(msg=("Order", m), from_=replica):
        # Parse message
        body, order_proofs = m
        request = Request.from_body(body)
        output("Received Order Command ID:", request.request_id)

        # If we are the head, do not process
        if replica != self.prev_replica:
            # Todo: Should we report misbehavior? (ie. the head shouldn't receive order commands)
            output("Received an order command but not from the previous replica in the chain")
            return
        else:
            # Make sure our status is Active
            if self.status != STATUS.ACTIVE:
                # Do nothing
                return

            # Todo: Check for valid order proofs and results, etc...

            # Get the slot number
            slot_num = order_proofs[-1][0]
            # Generate the order statement
            order = order_command(request)
            order_stmt = (slot_num, order)

            return forward_results(request, order_proofs, order_stmt)

    # Handler for client retransmission
    def receive(msg=("Retransmission", body), from_=client):
        # Parse Request
        request = Request.from_body(body)
        output("Received Retransmit Request ID", request.request_id)

        found_in_cache = False

        # Make sure our status is Active
        if self.status != STATUS.ACTIVE:
            # Send an Error response and exit
            return send(("Error", ("Not Active", request.request_id)), to= client)
        # Todo: Check the cache for a response
        elif found_in_cache:
            output("Found in cache")
        else:
            # Check if we are the head replica
            if self.head:
                # Todo: Check if there is a pending request (ie. There is a request in the sent list with the request_id)
                pending_request = False
                if pending_request:
                    # Wait for a shuttle response with a timeout
                    shuttle_response = False
                    if await(shuttle_response):
                        # Check status, which can change while we await
                        if self.status == STATUS.ACTIVE:
                            # Todo: Get the response from the shuttle
                            response = "Gotten"
                            # Send the response to the client and exit
                            return send("Response", (response, request.request_id), to= client)
                    # No response obtained
                    elif timeout(timeout):
                        # Become immutable and reconfigure
                        self.status == STATUS.IMMUTABLE
                        # Todo: Send reconfiguration request to Olympus
                        return
                else:
                    # Treat this retransmission as a new request
                    output("Treating Retransmission as a New Request")

                    return process_new_request(request)
            # If we are not the head replica
            else:
                # Forward the request to the head replica and set a timer
                head_replica = self.head_replica
                send(("Retransmission", body), to=head_replica)

                # Wait for a shuttle response with a timeout
                shuttle_response = False
                if await(shuttle_response):
                    # Todo: Get the response from the shuttle
                    response = "Gotten"
                    # Send the response to the client and exit
                    return send("Response", (response, request.request_id), to=client)
                # No response obtained
                elif timeout(timeout):
                    # Become immutable and reconfigure
                    self.status == STATUS.IMMUTABLE
                    # Todo: Send reconfiguration request to Olympus
                    return