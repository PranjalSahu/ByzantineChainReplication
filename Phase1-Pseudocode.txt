#User will create this object to send using a Client
UserRequest {
    fields:
        objectId
        operation
}


#Client creates this object to send to a head replica
ClientRequest {
    fields:
        objectId
        operation
        clientKey
        requestId

    methods:
        constructor(obj_id, op, key):
            self.objectId = obj_id
            self.operation = op
            self.clientKey = key
}


#Result received from a tail replica
Result {
    requestID
    result
    resultProof
}


#User will create a Client to send/receive multiple UserRequests
Client {
    fields:
        key
        timeoutSpan
        sent     #Set of sent requests
        received #Set of received responses
    
    methods:
        constructor(tSpan):
            self.key = Olympus.obtainClientKey()
            self.timeoutSpan = tSpan

        #User should use this interface
        sendRequest(UserRequest):
            #Todo: Create a requestID

            #Get the current configuration
            config = Olympus.getCurrectConfig()

            #Send a request to the head replica
            dest = config.head
            return __sendRequest(UserRequest, replicas = dest)

        __sendRequest(UserRequest, replicas):
            config = Olympus.getCurrectConfig()

            #Create a request
            request = new ClientRequest(obj_id = UserRequest.objectId, op = UserRequest.operation, key = self.key)

            #Send the request to the head node
            config.sendRequest(client = selfkey, requestBody = request, nodes = replicas)
            sent.add(request)

            timeout(minutes = self.timeoutSpan):
                #Check if we have received
                if request.requestID not in received:
                    #Get the current config. This updates the config incase there are any changes
                    config = Olympus.getCurrectConfig()
                    self.__sendRequest(UserRequest, replicas = config.getAllReplicas())


        #Receive an unvalidated result
        #Note: We assume a user may get mulitple responses for a single request
        receiveReplicaResponse(Result):
            if Result.requestId in sent:
                for each proof in Result.resultProofs
                    replicaPublicKey = config.replicas(proof.replicaID).publicKey
                    if HMAC(Result.result, replicaPublicKey) != proof.signature
                        return error

            return Result.result


        #Received an error. This means the sender replica is immutable
        receiveError(Error):
            config = Olympus.getCurrectConfig()
            __sendRequest(UserRequest, replicas = config.getAllReplicas())
}




Config:



Olymupus {
    fields:
        config #Ordered list of replicas
        

    methods:
        constructor(numberOfReplicas):
            self.config = new Config()
            initHist(self.config)            


        #Creates a new configuration
        initHist(numberOfReplicas, config, hist):
            #Delete old replicas
            config.purgeReplicas()

            #Create each replica
            for 0 to numberOfReplicas:
                r = new Replica(interReplicaKey = privateKey, signingKey = , status = Active, history = hist)
                #Add the replica to the config
                config.add(r)

            #Link each replica
            for each replica in config:
                if replica is not the head:
                    replica.previousReplica = replica.index-1
                    replica.headReplica = first replica in config
                if replica is not the tail:
                    replica.nextReplica = replica.index+1
                replica


        #Returns a new identifier and key to the client
        receiveClientKeyRequest():
	        return generateRandomKey()
        

        #Asynchronous method to handle requests from Clients to obtain the replica list
        getCurrectConfig():
            return self.config


        receiveReconfigureRequest():
            #Request wedge statements
            for each replica in config:


            #Remove invalid histories

            #Find the maximal orderproofs

            #Create a new configuration


}
    


Replica {
    fields:
        previousReplica
        nextReplica
        headReplica    # the address to head Replica
        history
        interReplicaKey
        signingKey
        status
        neighbors
        cache          # cache for storing the results
        headFlag       # boolean flag to check if replica is head or not 
        tailFlag       # boolean flag to check if replica is tail or not
    
    methods:
        # interReplicaKey is a list of signing key for 2t replicas
        # secretSigningKey will have signing key for each client
        
        constructor(interReplicaKey, secretSigningKey, status, neighbors):
            self.status           = status
            self.interReplicaKey  = interReplicaKey
            self.secretSigningKey = secretSigningKey
            self.neighbors        = neighbours
        
        # handle a request obtained from a client
        handleRequest(client, request):
            if self.status == Immutable:
		return Error
            else:
                if request.id in cache:
                    return cache[request.id]
                else:
		    if self.headFlag ==  False:     # forward the request to head
                          sendRequestToReplica(headReplica, request)

        orderCommand(operation, objectId, ):
            
}

OrderProof {
    fields:
        proofs  # list of proofs
        issuer  # the issuer of this proof        
}

Proof {
    fields:
        issuer     # the issuer of the proof which will be the replica id
        operation  # the operation which was performed
        objectId   # object on which operation was performed
        slot       # the unique operation number        
        

}

Shuttle{

}
