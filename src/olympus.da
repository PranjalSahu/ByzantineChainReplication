import nacl.encoding
import nacl.signing
import logging
import itertools

from status import STATUS
Request = import_da('request').Request
OPTYPE = import_da('request').OPTYPE
Replicas = import_da('replica').Replica
logger = logging.getLogger('main_logger')


class Olympus(process):

    def setup(failure_count: int, head_timeout: int, nonhead_timeout: int, allfailures: list, checkpt_interval: int):
        self.replica_count = failure_count * 2 + 1
        self.registered_clients  = {}
        self.checkpoint_interval = checkpt_interval
        self.configuration_index_counter = itertools.count()
        new_config = self.initHist(self.replica_count, {}, -1, allfailures)
        self.replicas, self.public_keys, self.private_keys, self.config_index = new_config
        self.pending_config_index = self.config_index - 1

    def run():
        await(False)

    def generate_sign_keys(replica_count):
        public_replica_keys = []
        private_replica_keys = []

        for i in range(replica_count):
            signing_key = nacl.signing.SigningKey.generate()
            verify_key = signing_key.verify_key
            private_replica_keys.append(signing_key)
            public_replica_keys.append(verify_key)

        return public_replica_keys, private_replica_keys

    # Creates a new configuration
    def initHist(number_of_replicas, runningState, slot_num, allfailures):
        # Increment the current configuration index
        next_config = next(self.configuration_index_counter)
        # Generate replica keys
        pub_keys, priv_keys = generate_sign_keys(number_of_replicas)
        # Create replica list
        replica_list = list(new(Replicas, num=number_of_replicas))

        head_replica = replica_list[0]
        for i, replica in enumerate(replica_list):
            private_key  = priv_keys[i]
            next_replica = None
            prev_replica = None

            headflag = (i==0)
            tailflag = (i==number_of_replicas-1)

            if not tailflag:
                next_replica = replica_list[i+1]
            if not headflag:
                prev_replica = replica_list[i-1]

            if headflag:
                replica_timeout = head_timeout
            else:
                replica_timeout = nonhead_timeout

            # setup(state: dict, timeout: int, replicas: list, head: Replica, tail: Replica, next_replica: Replica, prev_replica: Replica):
            setup(replica, (runningState,
                            slot_num,
                            replica_timeout,
                            pub_keys,
                            private_key,
                            STATUS.ACTIVE,
                            headflag,
                            tailflag,
                            next_replica,
                            prev_replica,
                            head_replica,
                            allfailures[i],
                            i,
                            self,
                            next_config,
                            self.checkpoint_interval))

        start(replica_list)
        return replica_list, pub_keys, priv_keys, next_config

    def receive(msg=("GetConfig", body), from_=client):
        m_req_id, m_id, m_publickey = body
        logger.debug("Received config request from Client ID: " + str(m_id))
        registered_clients[m_id] = m_publickey
        response = (m_req_id, self.replicas, self.public_keys)
        send(("ConfigResponse", response), to=client)
        logger.debug("Sent response for config request to client " + str(m_id))

    # Handler for wedge responses
    def receive(msg=("wedgeResponse", body), from_=sender):
        logger.debug("Received a wedge response from: " + str(sender))

    # This validates the wedge response
    def validate_wedge_reponse(resp, sender, responses):
        index, _, _ = resp
        # Validate that the sender is a replica
        if sender not in self.replicas:
            return False

        # Validate the configuration number
        if index != self.pending_config_index:
            return False

        # Validate that the sender hasn't sent a previous wedge response
        if sender in responses:
            return False

        responses[sender] = resp
        return True

    def get_wedge_responses():
        current_set = dict()
        s = setof(rep, received(('wedgeResponse', resp), from_=rep), validate_wedge_reponse(resp, rep, current_set))
        return s, current_set

    def sufficient_wedge_responses():
        responses, _ = get_wedge_responses()
        return len(responses) > self.failure_count + 1

    # Handler for reconfiguration requests
    def receive(msg=("ReConfig", body), from_=sender):
        error_type, replica_id, request_id, configuration = body
        logger.debug("Received Reconfig request from " + str(sender) + ' for error_type: ' + str(error_type) +
                    ' with configuration ' + str(configuration))

        # If not a replica, Check for provable misbehavior
        if sender not in self.replicas:
            logger.debug("Reconfig comes from a client")
            # Todo: Check for provable misbehavior, otherwise exit
            provable_misbehavior = True
            if not provable_misbehavior:
                logger.debug("Misbehavior is not provable. Will not reconfigure.")
                return
            else:
                logger.debug("Misbehavior proven... Will attempt to reconfigure.")
        else:
            logger.debug("Reconfig comes from a replica")

        # Careful with this... Using the pending_config_index variable as a lock to get rid of mutliple wedge requests. 
        #   This means that past this point, the reconfiguration must be successful
        if self.pending_config_index >= configuration:
            logger.debug("Previously received a reconfig request for this configuration. Ignoring request for configuration " + str(configuration))
            return
        else:
            logger.info("New reconfig request. Processing...")
            self.pending_config_index = self.config_index
        
        # Send wedge requests to all replicas
        for replica in self.replicas:
            wedge_req_body = ()
            wedge_req = ("wedgeRequest", wedge_req_body)
            send(wedge_req, to=replica)

        # Dangerous...
        # Todo: The await statement should validate the pending_config_index, the sender's identity as a replica, and the 
        # uniqueness of the sender (ie. the message shouldn't be sent more than once by a single replica)
        logger.info("Waiting for wedge responses for configuration: " + str(self.pending_config_index) + " -- " + str(configuration))

        if await(sufficient_wedge_responses()):
            logger.info("Received sufficient wedge responses")
            
            # Get replica state for quorum
            _, wedge_state = get_wedge_responses()
            logger.info("Head replica state:")
            logger.info(wedge_state[self.replicas[0]])
            _, head_state, head_slot = wedge_state[self.replicas[0]]
            
            # Todo: Validate replica state, proofs, etc

            # Todo: Send catchup messages

            # Stop all replicas
            end(self.replicas, -1)
            # Create a new initHist
            logger.info("Calling initHist to create a new set of replicas")
            new_config = self.initHist(self.replica_count, head_state, head_slot, allfailures)
            # Setting variables
            self.replicas, self.public_keys, self.private_keys, self.config_index = new_config
            logger.info("Successfully Reconfigured.")
